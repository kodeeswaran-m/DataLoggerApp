frontend end/ backend end : npm run dev


// config/cloudinary.js
const cloudinary = require("cloudinary").v2;
const dotenv = require("dotenv");

dotenv.config();

cloudinary.config({
  cloud_name: process.env.CLOUD_NAME,
  api_key: process.env.CLOUD_KEY,
  api_secret: process.env.CLOUD_SECRET,
});

module.exports = cloudinary;const mongoose = require('mongoose');

const connectDB = async () => {
  const uri = process.env.MONGO_URI || 'mongodb://localhost:27017/prospectDetails_db';
  try {
    await mongoose.connect(uri, {
    });
    console.log('MongoDB connected');
  } catch (err) {
    console.error('MongoDB connection error:', err.message);
    process.exit(1);
  }
};

module.exports = connectDB;// config/multerConfig.js
const multer = require("multer");

// store file in memory
const storage = multer.memoryStorage();

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
});

module.exports = { upload };// // controllers/prospectDetailController.js
// const ProspectDetail = require("../models/prospectDetail");
// const cloudinary = require("../config/cloudinary");

// exports.createProspectDetail = async (req, res, next) => {
//   try {
//     const payload = req.body || {};

//     // Basic validation
//     if (!payload.month || !payload.quarter || !payload.prospect) {
//       return res.status(400).json({
//         success: false,
//         message: "month, quarter and prospect are required"
//       });
//     }

//     // If file uploaded -> upload to Cloudinary
//     if (req.file) {
//       const uploadToCloudinary = () => {
//         return new Promise((resolve, reject) => {
//           const stream = cloudinary.uploader.upload_stream(
//             { folder: "prospectDetail_decks" },
//             (error, result) => {
//               if (error) return reject(error);
//               resolve(result);
//             }
//           );
//           stream.end(req.file.buffer);
//         });
//       };

//       const uploaded = await uploadToCloudinary();
//       payload.deck = uploaded.secure_url;
//       payload.deckPublicId = uploaded.public_id;
//     }

//     // calls: ensure call fields are objects if sent as strings
//     if (typeof payload.call1_checked !== "undefined") {
//       payload.call1 = {
//         checked: payload.call1_checked === "true" || payload.call1_checked === true,
//         notes: payload.call1_notes || ""
//       };
//     }
//     if (typeof payload.call2_checked !== "undefined") {
//       payload.call2 = {
//         checked: payload.call2_checked === "true" || payload.call2_checked === true,
//         notes: payload.call2_notes || ""
//       };
//     }
//     if (typeof payload.call3_checked !== "undefined") {
//       payload.call3 = {
//         checked: payload.call3_checked === "true" || payload.call3_checked === true,
//         notes: payload.call3_notes || ""
//       };
//     }

//     const opp = new ProspectDetail(payload);
//     await opp.save();

//     return res.status(201).json({ success: true, data: opp });
//   } catch (err) {
//     console.error("createProspectDetail error:", err);
//     next(err);
//   }
// };

// exports.getProspectDetails = async (req, res, next) => {
//   try {
//     const { page = 1, limit = 20, prospect, geo, rag } = req.query;
//     const query = {};

//     if (prospect) query.prospect = { $regex: prospect, $options: "i" };
//     if (geo) query.geo = geo;
//     if (rag) query.rag = rag;

//     // Ensure page and limit are numbers with safe defaults
//     const pageNum = Number.isNaN(parseInt(page, 10)) ? 1 : parseInt(page, 10);
//     const limitNum = Number.isNaN(parseInt(limit, 10)) ? 20 : parseInt(limit, 10);

//     const skip = (pageNum - 1) * limitNum;

//     const [items, total] = await Promise.all([
//       ProspectDetail.find(query)
//         .sort({ createdAt: -1 })
//         .skip(skip)
//         .limit(limitNum),
//       ProspectDetail.countDocuments(query)
//     ]);

//     res.json({
//       success: true,
//       data: items,
//       meta: { page: pageNum, limit: limitNum, total }
//     });
//   } catch (err) {
//     next(err);
//   }
// };

// exports.getProspectDetailById = async (req, res, next) => {
//   try {
//     const { id } = req.params;
//     const opp = await ProspectDetail.findById(id);
//     if (!opp) {
//       return res.status(404).json({ success: false, message: "ProspectDetail not found" });
//     }
//     res.json({ success: true, data: opp });
//   } catch (err) {
//     next(err);
//   }
// };

// exports.updateProspectDetail = async (req, res, next) => {
//   try {
//     const { id } = req.params;
//     const payload = req.body;
//     const opp = await ProspectDetail.findByIdAndUpdate(id, payload, {
//       new: true,
//       runValidators: true
//     });
//     if (!opp) {
//       return res.status(404).json({ success: false, message: "ProspectDetail not found" });
//     }
//     res.json({ success: true, data: opp });
//   } catch (err) {
//     next(err);
//   }
// };

// exports.deleteProspectDetail = async (req, res, next) => {
//   try {
//     const { id } = req.params;
//     const opp = await ProspectDetail.findById(id);
//     if (!opp) {
//       return res.status(404).json({ success: false, message: "ProspectDetail not found" });
//     }

//     if (opp.deckPublicId) {
//       try {
//         await cloudinary.uploader.destroy(opp.deckPublicId);
//       } catch (err) {
//         console.error("Cloudinary destroy error:", err);
//       }
//     }

//     await ProspectDetail.findByIdAndDelete(id);
//     res.json({ success: true, message: "Deleted successfully" });
//   } catch (err) {
//     next(err);
//   }
// };


// controllers/prospectDetailController.js
const ProspectDetail = require("../models/prospectDetailModel");
const cloudinary = require("../config/cloudinary");

// CREATE
exports.createProspectDetail = async (req, res, next) => {
  try {
    const payload = req.body || {};

    // Basic validation
    if (!payload.month || !payload.quarter || !payload.prospect) {
      return res.status(400).json({
        success: false,
        message: "month, quarter and prospect are required",
      });
    }

    // Upload file to Cloudinary if present
    if (req.file) {
      const uploaded = await new Promise((resolve, reject) => {
        cloudinary.uploader.upload_stream(
          { folder: "prospectDetail_decks" },
          (error, result) => {
            if (error) reject(error);
            else resolve(result);
          }
        ).end(req.file.buffer);
      });

      payload.deck = uploaded.secure_url;
      payload.deckPublicId = uploaded.public_id;
    }

    // Normalize call fields
    if (typeof payload.call1_checked !== "undefined") {
      payload.call1 = {
        checked: payload.call1_checked === "true" || payload.call1_checked === true,
        notes: payload.call1_notes || "",
      };
    }
    if (typeof payload.call2_checked !== "undefined") {
      payload.call2 = {
        checked: payload.call2_checked === "true" || payload.call2_checked === true,
        notes: payload.call2_notes || "",
      };
    }
    if (typeof payload.call3_checked !== "undefined") {
      payload.call3 = {
        checked: payload.call3_checked === "true" || payload.call3_checked === true,
        notes: payload.call3_notes || "",
      };
    }

    const opp = await ProspectDetail.create(payload);

    res.status(201).json({ success: true, data: opp });
  } catch (err) {
    console.error("createProspectDetail error:", err);
    next(err);
  }
};

// GET WITH PAGINATION + FILTERS
exports.getProspectDetails = async (req, res, next) => {
  try {
    const { page = 1, limit = 20, prospect, geo, rag } = req.query;
    const query = {};

    if (prospect) query.prospect = { $regex: prospect, $options: "i" };
    if (geo) query.geo = geo;
    if (rag) query.rag = rag;

    const pageNum = Number.isNaN(parseInt(page, 10)) ? 1 : parseInt(page, 10);
    const limitNum = Number.isNaN(parseInt(limit, 10)) ? 20 : parseInt(limit, 10);
    const skip = (pageNum - 1) * limitNum;

    const [items, total] = await Promise.all([
      ProspectDetail.find(query).sort({ createdAt: -1 }).skip(skip).limit(limitNum),
      ProspectDetail.countDocuments(query),
    ]);

    res.json({
      success: true,
      data: items,
      meta: { page: pageNum, limit: limitNum, total },
    });
  } catch (err) {
    next(err);
  }
};

// GET BY ID
exports.getProspectDetailById = async (req, res, next) => {
  try {
    const { id } = req.params;
    const opp = await ProspectDetail.findById(id);
    if (!opp) {
      return res.status(404).json({ success: false, message: "ProspectDetail not found" });
    }
    res.json({ success: true, data: opp });
  } catch (err) {
    next(err);
  }
};

// UPDATE
exports.updateProspectDetail = async (req, res, next) => {
  try {
    const { id } = req.params;
    const payload = req.body;
    const opp = await ProspectDetail.findByIdAndUpdate(id, payload, {
      new: true,
      runValidators: true,
    });
    if (!opp) {
      return res.status(404).json({ success: false, message: "ProspectDetail not found" });
    }
    res.json({ success: true, data: opp });
  } catch (err) {
    next(err);
  }
};

// DELETE
exports.deleteProspectDetail = async (req, res, next) => {
  try {
    const { id } = req.params;
    const opp = await ProspectDetail.findById(id);
    if (!opp) {
      return res.status(404).json({ success: false, message: "ProspectDetail not found" });
    }

    if (opp.deckPublicId) {
      try {
        await cloudinary.uploader.destroy(opp.deckPublicId);
      } catch (err) {
        console.error("Cloudinary destroy error:", err);
      }
    }

    await ProspectDetail.findByIdAndDelete(id);
    res.json({ success: true, message: "Deleted successfully" });
  } catch (err) {
    next(err);
  }
};const multer = require("multer");

const storage = multer.memoryStorage();

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // optional: 5 MB
});

module.exports = upload.single("file"); // ðŸ‘ˆ IMPORTANTconst mongoose = require('mongoose');

const CallSchema = new mongoose.Schema({
  checked: { type: Boolean, default: false },
  notes: { type: String, trim: true, default: '' }
}, { _id: false });

const ProspectDetailSchema = new mongoose.Schema({
  month: { type: String, trim: true, required: true },
  quarter: { type: String, trim: true, required: true },
  prospect: { type: String, trim: true, required: true },
  geo: { type: String, trim: true },
  lob: { type: String, trim: true },
  call1: { type: CallSchema, default: () => ({}) },
  call2: { type: CallSchema, default: () => ({}) },
  call3: { type: CallSchema, default: () => ({}) },
  coreOfferings: { type: String, trim: true },
  primaryNeed: { type: String, trim: true },
  secondaryNeed: { type: String, trim: true },
  trace: { type: String, trim: true },
  salesSpoc: { type: String, trim: true },
  oppId: { type: String, trim: true, index: true },
  oppDetails: { type: String, trim: true },
  deck: { type: String, trim: true }, // could be URL or filename
  deckPublicId: { type: String, trim: true }, // ADD THIS
  rag: { type: String, trim: true }, // RAG status (e.g., Red/Amber/Green)
  remark: { type: String, trim: true },

  // metadata
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// Update updatedAt on save/update
ProspectDetailSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('ProspectDetail', ProspectDetailSchema);// models/prospectDetailModel.js
const mongoose = require("mongoose");

const ProspectSchema = new mongoose.Schema(
  {
    month: String,
    prospect: String,
    geo: String,
    named: String,
    lob: String,
    call1: String,
    call2: String,
    call3: String,
    coreOfferings: String,
    primaryNeed: String,
    secondaryNeed: String,
    trace: String,
    salesSPOC: String,
    opportunityId: String,
    opportunityStatus: String,
    rag: String,
    remarks: String,

    deckUrl: { type: String, default: "" },
  },
  { timestamps: true }
);

module.exports = mongoose.model("ProspectDetail", ProspectSchema);// routes/prospectDetailRoutes.js
const express = require("express");
const router = express.Router();
const controller = require("../controllers/prospectDetailController");
const upload = require("../middleware/upload");

// POST /api/prospectDetail â†’ with file upload
router.post("/", upload.single("deck"), controller.createProspectDetail);

// GET /api/prospectDetail â†’ list (supports ?page=&limit=&prospect=&geo=&rag=)
router.get("/", controller.getProspectDetails);

// GET /api/prospectDetail/:id â†’ get single
router.get("/:id", controller.getProspectDetailById);

// PUT /api/prospectDetail/:id â†’ update
router.put("/:id", controller.updateProspectDetail);

// DELETE /api/prospectDetail/:id â†’ delete
router.delete("/:id", controller.deleteProspectDetail);

module.exports = router;// server.js
const express = require("express");
const cors = require("cors");
const dotenv = require("dotenv");
const connectDB = require("./config/db"); // <-- your connectDB file
const prospectRoutes = require("./routes/prospectDetailRoutes");

dotenv.config();
const app = express();

// Middlewares
app.use(cors());
app.use(express.json());

// Routes
app.use("/api/prospectDetail", prospectRoutes);

// DB Connection
connectDB();

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
This is frontend part of code 
import React from "react";
import type { ChangeEvent } from "react";
import type { DynamicFieldProps } from "./DynamicFormField.types";

const DynamicFormField: React.FC<DynamicFieldProps> = (props) => {
  const groupClass = `form-group ${props.className ?? ""}`;

  /* ---------------- TEXT INPUT ---------------- */
  if (props.type === "text") {
    return (
      <div className={groupClass}>
        <label htmlFor={props.name}>{props.label}</label>
        <input
          id={props.name}
          type="text"
          value={props.value ?? ""}
          placeholder={props.placeholder}
          disabled={props.disabled}
          onChange={(e) => props.onChange?.(e.target.value)}
        />
      </div>
    );
  }

  /* ---------------- TEXTAREA ---------------- */
  if (props.type === "textarea") {
    return (
      <div className={groupClass}>
        <label>{props.label}</label>
        <textarea
          value={props.value ?? ""}
          rows={props.rows ?? 4}
          placeholder={props.placeholder}
          disabled={props.disabled}
          onChange={(e) => props.onChange?.(e.target.value)}
        />
      </div>
    );
  }

  /* ---------------- SELECT ---------------- */
  if (props.type === "select") {
    return (
      <div className={groupClass}>
        <label>{props.label}</label>
        <select
          value={props.value ?? ""}
          disabled={props.disabled}
          onChange={(e) => props.onChange?.(e.target.value)}
        >
          <option value="">-- Select --</option>
          {props.options.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      </div>
    );
  }

  /* ---------------- FILE UPLOAD ---------------- */
  if (props.type === "file") {
    return (
      <div className={groupClass}>
        <label>{props.label}</label>
        <input
          type="file"
          onChange={(e: ChangeEvent<HTMLInputElement>) => {
            const file = e.target.files?.[0] ?? null;
            if (file) {
              props.onChange?.(file.name);
              props.onFileSelect?.(file);
            }
          }}
        />
      </div>
    );
  }

  /* ---------------- CHECKBOX + TEXT ---------------- */
  if (props.type === "checkbox-with-text") {
    return (
      <div className={`checkbox-row ${props.className ?? ""}`}>
        <input
          type="checkbox"
          checked={props.checked}
          onChange={(e) => props.onChange?.(e.target.checked)}
        />
        <label>{props.label}</label>

        {props.checked && (
          <input
            type="text"
            placeholder={props.textField.placeholder}
            value={props.textField.value}
            className="checkbox-note"
            onChange={(e) => props.onTextFieldChange?.(e.target.value)}
          />
        )}
      </div>
    );
  }

  return null;
};

export default DynamicFormField;
export type BaseFieldProps<T> = {
  label: string;
  name: string;
  value?: T;
  required?: boolean;
  disabled?: boolean;
  className?: string;
};

/* ---------------- TEXT FIELD ---------------- */
export type TextFieldProps = BaseFieldProps<string> & {
  type: "text";
  placeholder?: string;
  onChange?: (value: string) => void;
};

/* ---------------- TEXTAREA ---------------- */
export type TextAreaFieldProps = BaseFieldProps<string> & {
  type: "textarea";
  placeholder?: string;
  rows?: number;
  onChange?: (value: string) => void;
};

/* ---------------- SELECT ---------------- */
export type SelectFieldProps = BaseFieldProps<string> & {
  type: "select";
  options: { label: string; value: string }[];
  onChange?: (value: string) => void;
};

/* ---------------- COMBOBOX ---------------- */
export type ComboBoxFieldProps = BaseFieldProps<string> & {
  type: "combobox";
  options: string[];
  onChange?: (value: string) => void;
};

/* ---------------- FILE FIELD ---------------- */
export type FileFieldProps = BaseFieldProps<string> & {
  type: "file";
  onChange?: (fileName: string) => void;
  onFileSelect?: (file: File) => void;
};

/* ---------------- CHECKBOX + TEXT ---------------- */
export type CheckboxWithTextProps = BaseFieldProps<boolean> & {
  type: "checkbox-with-text";
  checked: boolean;
  textField: {
    name: string;
    value: string;
    placeholder?: string;
  };
  onChange?: (checked: boolean) => void;
  onTextFieldChange?: (value: string) => void;
};

export type DynamicFieldProps =
  | TextFieldProps
  | TextAreaFieldProps
  | SelectFieldProps
  | ComboBoxFieldProps
  | FileFieldProps
  | CheckboxWithTextProps;import type { DynamicFieldProps } from "./DynamicFormField.types";


/**
 * Extended form fields. This is a plain configuration list.
 * Handlers are provided by the consumer (Demo).
 *
 * Note: onChange is optional here (the consumer wires handlers).
 */

export const extendedFormFields: DynamicFieldProps[] = [
  {
    type: "select",
    name: "month",
    label: "Month",
    value: "",
    required: true,
    options: [
      { label: "January", value: "jan" },
      { label: "February", value: "feb" },
      { label: "March", value: "mar" },
      { label: "April", value: "apr" },
      { label: "May", value: "may" },
      { label: "June", value: "jun" },
      { label: "July", value: "jul" },
      { label: "August", value: "aug" },
      { label: "September", value: "sep" },
      { label: "October", value: "oct" },
      { label: "November", value: "nov" },
      { label: "December", value: "dec" },
    ],
  },

  {
    type: "text",
    name: "quarter",
    label: "Quarter",
    placeholder: "Auto-filled",
    disabled: true,
    value: "",
  },

  {
    type: "text",
    name: "prospect",
    label: "Prospect",
    placeholder: "Enter prospect name",
    value: "",
  },

  {
    type: "select",
    name: "geo",
    label: "Geo Location",
    value: "",
    options: [
      { label: "APAC", value: "apac" },
      { label: "EMEA", value: "emea" },
      { label: "USA", value: "usa" },
      { label: "India", value: "india" },
    ],
  },

  {
    type: "select",
    name: "lob",
    label: "LOB",
    value: "",
    options: [
      { label: "Life Insurance", value: "life" },
      { label: "Health", value: "health" },
      { label: "General Insurance", value: "general" },
      { label: "Pension", value: "pension" },
    ],
  },

  {
    type: "checkbox-with-text",
    name: "call1",
    label: "Call 1",
    checked: false,
    textField: { name: "call1Notes", placeholder: "Notes for Call 1", value: "" },
  },

  {
    type: "checkbox-with-text",
    name: "call2",
    label: "Call 2",
    checked: false,
    textField: { name: "call2Notes", placeholder: "Notes for Call 2", value: "" },
  },

  {
    type: "checkbox-with-text",
    name: "call3",
    label: "Call 3",
    checked: false,
    textField: { name: "call3Notes", placeholder: "Notes for Call 3", value: "" },
  },

  {
    type: "select",
    name: "coreOfferings",
    label: "Core Offerings",
    value: "",
    options: [
      { label: "Product Development", value: "productDev" },
      { label: "Testing", value: "testing" },
      { label: "Cloud Migration", value: "cloud" },
      { label: "Support", value: "support" },
      { label: "Consulting", value: "consulting" },
    ],
  },

  {
    type: "text",
    name: "primaryNeed",
    label: "Primary Need",
    placeholder: "Enter primary need",
    value: "",
  },

  {
    type: "text",
    name: "secondaryNeed",
    label: "Secondary Need",
    placeholder: "Enter secondary need",
    value: "",
  },

  {
    type: "select",
    name: "category",
    label: "Category",
    value: "",
    options: [
      { label: "New", value: "new" },
      { label: "Existing", value: "existing" },
      { label: "Upgrade", value: "upgrade" },
    ],
  },

  {
    type: "text",
    name: "trace",
    label: "Trace",
    placeholder: "Enter trace",
    value: "",
  },

  {
    type: "select",
    name: "salesSpoc",
    label: "Sales SPOC",
    value: "",
    options: [
      { label: "Sanjay", value: "sanjay" },
      { label: "Rahul", value: "rahul" },
      { label: "Priya", value: "priya" },
      { label: "Arun", value: "arun" },
    ],
  },

  {
    type: "text",
    name: "oppId",
    label: "Opportunity ID",
    disabled: true,
    value: "AUTO-GENERATED",
  },

  {
    type: "textarea",
    name: "oppDetails",
    label: "Opportunity Details",
    disabled: true,
    value: "System generated details",
  },

  // deck is handled as a file input in Demo
  {
    type: "file",
    name: "deck",
    label: "Upload Deck (file input shown in UI)",
    value: "",
  },

  {
    type: "select",
    name: "rag",
    label: "RAG Status",
    value: "",
    options: [
      { label: "Red", value: "red" },
      { label: "Amber", value: "amber" },
      { label: "Green", value: "green" },
    ],
  },

  {
    type: "text",
    name: "remark",
    label: "Remark",
    placeholder: "Enter remark",
    value: "",
  },
];import React, { useState } from "react";
import DynamicFormField from "../components/DynamicFormField";
import type { DynamicFieldProps } from "../components/DynamicFormField.types";
import { monthToQuarter } from "../quarter";
import { createProspect } from "../services/ProspectDetailServices";
import "./Demo.css";

type CallKey = "call1" | "call2" | "call3";

type FormValues = {
  month: string;
  quarter: string;
  prospect: string;
  geo: string;
  lob: string;

  call1: { checked: boolean; notes: string };
  call2: { checked: boolean; notes: string };
  call3: { checked: boolean; notes: string };

  coreOfferings: string;
  primaryNeed: string;
  secondaryNeed: string;
  trace: string;
  salesSpoc: string;

  oppId: string;
  oppDetails: string;

  deck: string;
  rag: string;
  remark: string;
};

const Demo: React.FC = () => {
  const [file, setFile] = useState<File | null>(null);

  const [values, setValues] = useState<FormValues>({
    month: "",
    quarter: "",
    prospect: "",
    geo: "",
    lob: "",

    call1: { checked: false, notes: "" },
    call2: { checked: false, notes: "" },
    call3: { checked: false, notes: "" },

    coreOfferings: "",
    primaryNeed: "",
    secondaryNeed: "",
    trace: "",
    salesSpoc: "",

    oppId: "AUTO-GENERATED",
    oppDetails: "System generated details",

    deck: "",
    rag: "",
    remark: "",
  });

  const updateValue = (name: keyof FormValues, value: string) => {
    setValues((prev) => ({
      ...prev,
      [name]: value,
      ...(name === "month" && { quarter: monthToQuarter(value) }),
    }));
  };

  const updateCheckbox = (call: CallKey, checked: boolean) => {
    setValues((prev) => ({
      ...prev,
      [call]: { ...prev[call], checked },
    }));
  };

  const updateCheckboxText = (call: CallKey, notes: string) => {
    setValues((prev) => ({
      ...prev,
      [call]: { ...prev[call], notes },
    }));
  };

  const callFields = [
    { name: "call1", label: "Call 1 - Discovery / Solutions" },
    { name: "call2", label: "Call 2 - Solutions / Offerings" },
    { name: "call3", label: "Call 3 - POC / Proposal" },
  ] as const;

  const fields: DynamicFieldProps[] = [
    {
      type: "select",
      name: "month",
      label: "Month",
      value: values.month,
      options: [
        { label: "January", value: "jan" },
        { label: "February", value: "feb" },
        { label: "March", value: "mar" },
        { label: "April", value: "apr" },
        { label: "May", value: "may" },
        { label: "June", value: "jun" },
        { label: "July", value: "jul" },
        { label: "August", value: "aug" },
        { label: "September", value: "sep" },
        { label: "October", value: "oct" },
        { label: "November", value: "nov" },
        { label: "December", value: "dec" },
      ],
      onChange: (v) => updateValue("month", v),
    },
    {
      type: "text",
      name: "quarter",
      label: "Quarter",
      value: values.quarter,
      disabled: true,
    },
    {
      type: "text",
      name: "prospect",
      label: "Prospect",
      value: values.prospect,
      placeholder: "Enter prospect name",
      onChange: (v) => updateValue("prospect", v),
    },
    {
      type: "select",
      name: "geo",
      label: "Geo",
      value: values.geo,
      options: [
        { label: "APAC", value: "apac" },
        { label: "EMEA", value: "emea" },
        { label: "USA", value: "usa" },
        { label: "India", value: "india" },
      ],
      onChange: (v) => updateValue("geo", v),
    },
    {
      type: "select",
      name: "lob",
      label: "LOB",
      value: values.lob,
      options: [
        { label: "Life Insurance", value: "life" },
        { label: "Health", value: "health" },
        { label: "General Insurance", value: "general" },
        { label: "Pension", value: "pension" },
      ],
      onChange: (v) => updateValue("lob", v),
    },

    {
      type: "select",
      name: "coreOfferings",
      label: "Core Offerings",
      value: values.coreOfferings,
      options: [
        { label: "Product Development", value: "productDev" },
        { label: "Testing", value: "testing" },
        { label: "Cloud Migration", value: "cloud" },
        { label: "Support", value: "support" },
        { label: "Consulting", value: "consulting" },
      ],
      onChange: (v) => updateValue("coreOfferings", v),
    },

    {
      type: "text",
      name: "primaryNeed",
      label: "Primary Need",
      value: values.primaryNeed,
      placeholder: "Enter primary need",
      onChange: (v) => updateValue("primaryNeed", v),
    },

    {
      type: "text",
      name: "secondaryNeed",
      label: "Secondary Need",
      value: values.secondaryNeed,
      placeholder: "Enter secondary need",
      onChange: (v) => updateValue("secondaryNeed", v),
    },

    {
      type: "textarea",
      name: "trace",
      label: "Trace",
      value: values.trace,
      placeholder: "Enter trace",
      onChange: (v) => updateValue("trace", v),
      className: "full",
    },

    {
      type: "select",
      name: "salesSpoc",
      label: "Sales SPOC",
      value: values.salesSpoc,
      options: [
        { label: "Sanjay", value: "sanjay" },
        { label: "Rahul", value: "rahul" },
        { label: "Priya", value: "priya" },
        { label: "Arun", value: "arun" },
      ],
      onChange: (v) => updateValue("salesSpoc", v),
    },

    { type: "text", name: "oppId", label: "Opportunity ID", value: values.oppId, disabled: true },

    {
      type: "textarea",
      name: "oppDetails",
      label: "Opportunity Details",
      value: values.oppDetails,
      disabled: true,
      className: "full",
    },

    {
      type: "file",
      name: "deck",
      label: "Deck",
      value: values.deck,
      onChange: (fileName) => updateValue("deck", fileName),
      onFileSelect: (selectedFile) => setFile(selectedFile),
    },

    {
      type: "select",
      name: "rag",
      label: "RAG",
      value: values.rag,
      options: [
        { label: "Red", value: "red" },
        { label: "Amber", value: "amber" },
        { label: "Green", value: "green" },
      ],
      onChange: (v) => updateValue("rag", v),
    },

    {
      type: "text",
      name: "remark",
      label: "Remarks",
      value: values.remark,
      placeholder: "Enter remark",
      onChange: (v) => updateValue("remark", v),
      className: "full",
    },
  ];

  /** ---------- SUBMIT ---------- **/  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    const formData = new FormData();

    Object.entries(values).forEach(([key, value]) => {
      if (typeof value === "string") formData.append(key, value);
    });

    formData.append("call1_checked", values.call1.checked.toString());
    formData.append("call1_notes", values.call1.notes);

    formData.append("call2_checked", values.call2.checked.toString());
    formData.append("call2_notes", values.call2.notes);

    formData.append("call3_checked", values.call3.checked.toString());
    formData.append("call3_notes", values.call3.notes);

    if (file) formData.append("deckFile", file);

    try {
      const res = await createProspect(formData);
      alert("Form Submitted Successfully!");
      console.log("Response:", res);
    } catch (err) {
      console.error(err);
      alert("Error submitting form!");
    }
  };

  return (
    <div className="app-container">
      <div className="demo-card">
        <h1>Basic Data</h1>

        <form onSubmit={handleSubmit}>
          <div className="form-grid">
            {fields.slice(0, 5).map((f) => (
              <DynamicFormField key={f.name} {...f} />
            ))}

            <div className="section-card">
              {callFields.map((c) => (
                <DynamicFormField
                  key={c.name}
                  type="checkbox-with-text"
                  label={c.label}
                  name={c.name}
                  checked={values[c.name].checked}
                  textField={{
                    name: `${c.name}-notes`,
                    value: values[c.name].notes,
                    placeholder: `Notes for ${c.label.split(" -")[0]}`,
                  }}
                  onChange={(checked) => updateCheckbox(c.name, checked)}
                  onTextFieldChange={(val) => updateCheckboxText(c.name, val)}
                />
              ))}
            </div>

            {fields.slice(5).map((f) => (
              <DynamicFormField key={f.name} {...f} />
            ))}
          </div>

          <div className="form-actions">
            <button className="primary">Submit</button>
            <button className="ghost" type="button">Cancel</button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default Demo;import { useEffect, useState } from "react";
import ProspectDetailsTable from "../components/ProspectDetailsTable";
import { fetchProspects } from "../services/ProspectDetailServices";
import "./ProspectDetailsSummary.css";

const ProspectDetailsSummary = () => {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [limit] = useState(8);
  const [total, setTotal] = useState(0);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadData();
  }, [page]);

  const loadData = async () => {
    try {
      setLoading(true);
      const res = await fetchProspects(page, limit);
      setItems(res.data);
      setTotal(res.meta.total);
    } catch (err) {
      console.error(err);
    }
    setLoading(false);
  };

  return (
    <div className="summary-container">
      <div className="summary-card">
        <h1>Prospect Summary</h1>

        {loading ? (
          <p>Loading...</p>
        ) : (
          <ProspectDetailsTable data={items} />
        )}

        {/* Pagination */}
        <div className="pagination">
          <button disabled={page === 1} onClick={() => setPage((p) => p - 1)}>
            Prev
          </button>

          <span>
            Page {page} of {Math.ceil(total / limit)}
          </span>

          <button
            disabled={page >= Math.ceil(total / limit)}
            onClick={() => setPage((p) => p + 1)}
          >
            Next
          </button>
        </div>
      </div>
    </div>
  );
};

export default ProspectDetailsSummary;import axios from "axios";

const API_URL = "http://localhost:5000/api/ProspectDetail";

export const fetchProspects = async (page = 1, limit = 20) => {
  const res = await axios.get(`${API_URL}?page=${page}&limit=${limit}`);
  return res.data;
};

// â­ POST form-data with file upload
export const createProspect = async (formData: FormData) => {
  const res = await axios.post(API_URL, formData, {
    headers: {
      "Content-Type": "multipart/form-data",
    },
  });
  return res.data;
}; Clear all errors this is my backend and frontend codes analysis all this give corrected code which means If i send the data that store in db and fetch it on summary page  















